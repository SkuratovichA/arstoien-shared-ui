import { createContext, useEffect, useState, use, ReactNode } from 'react';
import { useMutation, useQuery } from '@apollo/client/react';
import { TypedDocumentNode } from '@apollo/client';

// Generic types for auth responses
export interface AuthUser {
  id: string;
  email: string;
  firstName: string;
  lastName: string;
  role: string;
  status: string;
  preferredLocale?: string;
  preferredCurrency?: string;
  [key: string]: unknown; // Allow additional fields
}

export interface AuthResponse {
  user: AuthUser;
  accessToken: string;
  refreshToken: string;
}

export interface CurrentUserResponse {
  currentUser: AuthUser | null;
}

// Auth context type
export interface AuthContextType {
  user: AuthUser | null;
  loading: boolean;
  error: Error | undefined;
  login: (email: string, password: string) => Promise<{ user: AuthUser; accessToken: string; refreshToken: string }>;
  register: (
    email: string,
    password: string,
    firstName: string,
    lastName: string,
  ) => Promise<{ user: AuthUser; accessToken: string; refreshToken: string }>;
  logout: () => Promise<void>;
  isAuthenticated: boolean;
}

export const AuthContext = createContext<AuthContextType | undefined>(undefined);

// GraphQL documents interface for dependency injection
// Using TypeScript generics for full type safety
// Accepts the exact types generated by GraphQL codegen
export interface AuthDocuments<
  TLoginData extends { login: unknown } = { login: AuthResponse },
  TLoginVars = unknown,
  TRegisterData extends { register: unknown } = { register: AuthResponse },
  TRegisterVars = unknown,
  TLogoutData extends { logout: unknown } = { logout: boolean },
  TLogoutVars = unknown,
  TCurrentUserData extends { currentUser: unknown } = CurrentUserResponse,
  TCurrentUserVars = unknown
> {
  LoginDocument: TypedDocumentNode<TLoginData, TLoginVars>;
  RegisterDocument: TypedDocumentNode<TRegisterData, TRegisterVars>;
  LogoutDocument: TypedDocumentNode<TLogoutData, TLogoutVars>;
  GetCurrentUserDocument: TypedDocumentNode<TCurrentUserData, TCurrentUserVars>;
}

/**
 * Factory function to create an AuthProvider with injected GraphQL documents
 * This allows shared-ui to be generic and not depend on app-specific generated types
 * Types are automatically inferred from the GraphQL documents passed in
 */
export function createAuthProvider<
  TLoginData extends { login: unknown },
  TLoginVars extends Record<string, unknown>,
  TRegisterData extends { register: unknown },
  TRegisterVars extends Record<string, unknown>,
  TLogoutData extends { logout: unknown },
  TLogoutVars extends Record<string, unknown>,
  TCurrentUserData extends { currentUser: unknown },
  TCurrentUserVars extends Record<string, unknown>
>(documents: AuthDocuments<TLoginData, TLoginVars, TRegisterData, TRegisterVars, TLogoutData, TLogoutVars, TCurrentUserData, TCurrentUserVars>) {
  return function AuthProvider({ children }: { children: ReactNode }) {
    const [user, setUser] = useState<AuthUser | null>(null);

    // Get current user - only if we have tokens
    const hasTokens =
      typeof window !== 'undefined' &&
      Boolean(localStorage.getItem('accessToken')) &&
      Boolean(localStorage.getItem('refreshToken'));

    const { loading, data, error, refetch } = useQuery(documents.GetCurrentUserDocument, {
      skip: !hasTokens,
      fetchPolicy: 'network-only',
      errorPolicy: 'all',
    } as never);

    const [loginMutation] = useMutation(documents.LoginDocument);
    const [registerMutation] = useMutation(documents.RegisterDocument);
    const [logoutMutation] = useMutation(documents.LogoutDocument);

    const login = async (email: string, password: string) => {
      const { data: loginData } = await loginMutation({
        variables: {
          input: { email, password },
        } as unknown as TLoginVars,
      });

      if (loginData?.login) {
        const authResponse = loginData.login as unknown as AuthResponse;
        // Store tokens in localStorage
        localStorage.setItem('accessToken', authResponse.accessToken);
        localStorage.setItem('refreshToken', authResponse.refreshToken);

        // Set user
        setUser(authResponse.user);

        // Refetch current user to get full data
        await refetch();
      }

      return loginData!.login as unknown as { user: AuthUser; accessToken: string; refreshToken: string };
    };

    const register = async (
      email: string,
      password: string,
      firstName: string,
      lastName: string,
    ) => {
      const { data: registerData } = await registerMutation({
        variables: {
          input: { email, password, firstName, lastName },
        } as unknown as TRegisterVars,
      });

      if (registerData?.register) {
        const authResponse = registerData.register as unknown as AuthResponse;
        // Store tokens in localStorage
        localStorage.setItem('accessToken', authResponse.accessToken);
        localStorage.setItem('refreshToken', authResponse.refreshToken);

        // Set user
        setUser(authResponse.user);

        // Refetch current user to get full data
        await refetch();
      }

      return registerData!.register as unknown as { user: AuthUser; accessToken: string; refreshToken: string };
    };

    const logout = async () => {
      try {
        await logoutMutation({} as never);
      } catch (error) {
        console.error('Logout mutation failed:', error);
      }

      // Clear tokens and user
      localStorage.removeItem('accessToken');
      localStorage.removeItem('refreshToken');
      setUser(null);
    };

    useEffect(() => {
      if (data?.currentUser) {
        setUser(data.currentUser as unknown as AuthUser);
      }
    }, [data?.currentUser]);

    // Clear tokens when auth query fails or returns null user
    useEffect(() => {
      // Clear tokens if query failed (invalid/expired tokens)
      if (error && hasTokens) {
        console.log('Auth query failed, clearing tokens');
        localStorage.removeItem('accessToken');
        localStorage.removeItem('refreshToken');
        setUser(null);
      }

      // Clear tokens if query succeeded but returned null (tokens exist but user is invalid)
      if (!loading && !error && data !== undefined && !data?.currentUser && hasTokens) {
        console.log('Auth query returned null user, clearing tokens');
        localStorage.removeItem('accessToken');
        localStorage.removeItem('refreshToken');
        setUser(null);
      }
    }, [error, loading, data, hasTokens]);

    const isAuthenticated = Boolean(user);

    return (
      <AuthContext.Provider
        value={{ user, loading, error, login, register, logout, isAuthenticated }}
      >
        {children}
      </AuthContext.Provider>
    );
  };
}

/**
 * React 19: Custom hook using the new use() hook
 * Must be used within an AuthProvider created by createAuthProvider()
 */
export const useAuth = () => {
  const context = use(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};
